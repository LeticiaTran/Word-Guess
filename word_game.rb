# Kirsten Schumy & Leticia Tran
# Ada[9], Ampers
# Week 2: Word Guess Game Assignment
# February 14, 2018

# SUMMARY:

  # This program is A game which will allow the user to guess a word and get
  # ASCII-art as feedback on their guesses.

  # The Rules:

    # The word to guess is represented by a row of dashes, giving the number of letters.
    # If the guess is a letter or number which occurs in the word, the word should be
    # updated in all of the correct positions. If the suggested letter or number does
    # not occur in the word, the game should draw or remove one element of the visual
    # representation as a tally mark. The game is over when:
    #  - The player completes the word, or guesses the whole word correctly
    #  - The diagram representing the tally marks is complete


  # Primary Requirements:

    # Game Play:

      # The user should be able to input a single letter at a time.
      # Between each guess, the board should be redrawn to the terminal (ASCII art!).
      # Display the letters that have already been guessed before each player guesses a
      # new letter.
      # The user should be able to win or lose.
    # Technical:

      # You should be able to play your game by running it using ruby from the terminal.
      # Use classes to contain your game logic. You may be able to implement your solution
      # using just one class, but consider how splitting functionality into separate
      # classes may increase your code's readability and maintainability.
      # Remember the single responsibility principle!


######################################################################
# GEMS:

require 'faker' # To generate a new random word from a specific theme.
require 'colorize' # To change colors on display

######################################################################
#CLASS GAME


class Game
  attr_reader :right_guesses

  # Accepts a random word(s) generated by the class Word as an argument
  # It initialize instances variables that will assist on the functionality of the game.
  def initialize(initial_word)
    @word = initial_word
    @right_guesses = current_guessed_letters
    @wrong_guesses = []
    @guesses_remaining = 5
  end

  # Method to get user input for guess:
  def get_input
    print "\nPlease enter a letter to guess > ".blue
    return gets.chomp.downcase
  end

  # Method to print ascii with chances updated, the right guesses and wrong guesses.
  def print_status
    print_ascii_art
    puts right_guesses.green
    print_wrong_guesses
  end

  # Method to set the number of guesses raainning to zero.
  def give_up
    guess_full_answer("")
  end

  # Returns true if there are no guesses remainning or if the right word has
  # been found. Otherwise return false.
  def game_over?
    return @guesses_remaining < 1  || @word.guessed_right_word(@right_guesses)
  end

  # Method that will check if there are no guesses remainning for the player to use
  # or if the right word has been already guessed.
  # Prints if the user has won or lost the game and displays the word that should be guessed.
  def display_end_of_game
    if game_over?
      @word.guessed_right_word(@right_guesses) ? (puts "\n#{"You won!".light_green.bold}") : (puts "You lost!".light_red.bold)
      puts "#{"Final word:".blue} #{@word.secret_word.light_green.bold}"
    end
  end

  # Method to return the user input if it has only one character and if that
  # character is a letter (from a to z).
  # It will prompt redirect to another method that will prompt the user if they
  # want to guess the whole word/sentece in case this input has the same length
  # as the secret word to be guessed.
  # If it doesnt comply with the requirements and it i not the same size as the
  # secret word, it will display a message explainning the requirements.
  def valid_input(user_input)
    return user_input if user_input.length == 1 && user_input.match?(/[a-z]/)
    if user_input.length == @right_guesses.length
      check_if_wants_to_guess_word(user_input)
    end
    puts print_line_in_blue("Please only enter #{"one".bold} letter")
  end


  # Method to prompt the user if wants to use all the guesses remainning to try and
  # guess the whole word(s).
  def check_if_wants_to_guess_word(user_input)
    final_guess = ""
    while final_guess != "y" && final_guess != "n"
      print "Are you sure you want to bet all of your lives on this guess? (y/n)".blue
      final_guess = gets.chomp.downcase
    end
    guess_full_answer(user_input) if final_guess == "y"
  end

  # Method runned if user decides to take the cahnce and guess full answer. Sets the
  # guesses remaining to zero and assign the righ_guesse as this final guess if correct.
  def guess_full_answer(final_guess)
    @guesses_remaining = 0
    @right_guesses = final_guess if @word.guessed_right_word(final_guess)
  end

  # Method to checks if user repeats a previous guessed word and return a warnning message.
  # Otherwise check if guess is right or wrong and displays the result of that guess.
  # If guess is wrong, it will subtract the variable containning the remainig guesses
  # by one.
  def process_guess_input(user_input)
    if @right_guesses.include?(user_input) || @wrong_guesses.include?(user_input)
      print_line_in_blue("You've already guessed the letter '#{user_input.bold}'!")
    elsif @word.has_letter?(user_input) #@secret_word.include?(user_input)
      update_new_guessed_word(user_input)
      puts "Yay!".green.bold
    else
      puts "Wrong!".red.bold
      @wrong_guesses << user_input
      @guesses_remaining -= 1
    end
  end

private

# Method to set string with the color blue and add a new line after it.
def print_line_in_blue(text_to_print)
  puts "#{text_to_print}".blue
end

def current_guessed_letters
  return @word.secret_word.gsub(/[^"#{@right_guesses}\s\W"]/,"_")
end

# Method to print a Ascii art in form of a potted plant with roses.
# Each rose means one chance/live remaining for the player.
# The number of roses will be displayed times instance variable that holds
# the amount of guesses remaining.
# - If only one rose left, it will be displayed blinking.
def print_ascii_art
  empty_space = "    "
  larger_empty_space = "     "
  if @guesses_remaining == 1
    puts "\n(@)".red.blink
  else
    puts  "\n#{"(@)" * @guesses_remaining}".red
  end
  puts "  ,\\,\\,|,/,/,".green
  puts "     _\\\|/_".green
  print empty_space
  puts"|_____|".yellow.on_light_yellow
  print larger_empty_space
  puts "|   |".yellow.on_light_yellow
  print larger_empty_space
  puts "|___|".yellow.on_light_yellow
  puts
end

# Method to loop trough the word to be guessed trying to match the letter on each index
# with the latest letter that the user entered, and substitute it in the instance
# variable containning the rigth guesses.
def update_new_guessed_word(user_input)
  @word.secret_word.length.times { |index| @right_guesses[index] =
    @word.secret_word[index] if @word.secret_word[index].downcase == user_input }
end

# Method to print letters input by the user that do not match the word(s) to be guessed
# if there are any.
def print_wrong_guesses
  puts "Wrong guesses: #{@wrong_guesses * ", "}".red if !@wrong_guesses.empty?
end

end


######################################################################
#CLASS WORD


class Word
  attr_reader :secret_word, :difficulty_level

  # Method to take the difficulty level chosen by the player/user as an argument and
  # assign a new word/sentence (by calling the respective method), to a new
  # instance variable.
  def initialize(initial_difficulty_level)
    @difficulty_level = initial_difficulty_level
    @secret_word = generate_random_word
  end

  # Method to generate and return a new random word/sentence based on the dificulty level
  # chosen by the user/player
  # - It uses the gem Faker in order to generate this word(s) based on different
  # themes.
  def generate_random_word
    case @difficulty_level
    when "easy"
      return Faker::Movie.quote
    when "medium"
      return Faker::Food.dish
    when "hard"
      return Faker::Color.color_name
    end
  end

  def guessed_right_word(current_letters)
    return @secret_word.casecmp?(current_letters)
  end

  # Prints game directions.
  def has_letter?(user_input)
    return @secret_word.downcase.include?(user_input)
  end

end


######################################################################
# FUNCTIONALITY METHODS


# Method to get user input regarding the desired difficulty of the game to be
# played and returns it, after validating it as a valid difficulty option.
def get_difficulty_level
  difficulty = ""
  until difficulty == "easy" ||  difficulty == "medium" || difficulty == "hard"
    print "Please select a difficulty level (easy, medium, hard) > ".blue
    difficulty = gets.chomp.strip
  end
  return difficulty
end

# Method to print text in blue.
# All the system/program related text should be in blue if prompting the user for
# an input or giving instructions.
def print_in_blue(text_to_print)
  print "#{text_to_print}".blue
end

# Method to handle the user input if equals to 'exit'
# It will prompt the user if really want to quit the program
# and if answer is 'y' then it will exit.
def handle_input(input_letter)
  if input_letter == "exit"
    print "Are you sure you want to exit? (y/n) > ".blue
    exit if gets.chomp.downcase == "y"
  end
end

# Method to print a welcome message and game directions, explainning the difficult level
# atrribute and how to use it.
def print_directions
  puts
  print_in_blue("Welcome to the Word Guess Game!\n\n")
  print_in_blue("When prompted for a letter, type #{"exit".bold} to quit the program or")
  print_in_blue("#{"restart".bold} to give up and start a new game.")
  print_in_blue("This game has three difficulty levels with different themes:")
  print_in_blue("#{'Easy'.bold} is random movie quotes.")
  print_in_blue("#{'Medium'.bold} is random dishes.")
  print_in_blue("#{'Hard'.bold} is random color.\n\n")
end

# Method to print string in blue and centralized on the user terminal's screen.
def print_in_blue(text_to_print)
  puts "#{text_to_print}".center(60).blue
end


# Method to initialize the game by printing directions, prompting user for a difficulty
# level and then initiating the class Game. It willl run until the game is over
# and handle game options like restart it self or quit the application.
def play_game
  print_directions
  difficulty_level = get_difficulty_level
  word_game = Game.new(Word.new(difficulty_level))
  until word_game.game_over?
    word_game.print_status
    input_letter = word_game.get_input
    handle_input(input_letter)
    if input_letter == "restart"
      word_game.give_up
      break
    end
    next if !word_game.valid_input(input_letter)
    word_game.process_guess_input(input_letter)
  end
  word_game.display_end_of_game
end

# Method to prompt the user for an yes or no answer on the matter of starting the game all
# over again after the game is over (when the user wins or looses).
def play_again?
  print "\nThe game is over! Would you like to play again? (Y/N) >".center(60).blue
  play_again_response = gets.chomp.downcase
  return play_again_response == "y" || play_again_response == "yes"
end


# Method to keep the program (game) running until commanded not to do so
# by the user through the method play_again.
play_again = true
while play_again
  play_game
  play_again = play_again?
end
